/**
 * SCSS 混合宏集合模块
 * 
 * 本模块是 wot-ui-plus 组件库中 SCSS 混合宏的核心集合，
 * 为组件样式开发提供强大的代码复用和抽象能力，支持 BEM 命名规范、
 * 常用样式工具和特殊视觉效果等高级样式功能。
 * 
 * 在项目架构中的作用：
 * - 样式抽象层：提供可复用的 SCSS 混合宏，简化样式开发复杂度
 * - BEM 规范支持：完整的 BEM 命名规范自动化处理能力
 * - 样式工具集：常用样式效果和布局工具的标准化实现
 * - 组件样式基础：为所有 UI 组件提供一致的样式抽象接口
 * 
 * 核心功能分类：
 * 1. BEM 命名规范：块(Block)、元素(Element)、修饰符(Modifier)相关混合宏
 * 2. 样式工具：文本处理、布局、边框等常用样式工具
 * 3. 特殊效果：箭头、按钮重置等特殊视觉效果
 * 4. 多端适配：支持 uniapp 多端开发的样式适配
 * 
 * 技术特色：
 * - 函数式抽象：通过混合宏实现样式逻辑的抽象和复用
 * - 智能上下文：根据选择器上下文智能生成合适的 CSS 选择器
 * - 样式穿透：支持 Vue 等框架的样式穿透(:deep())功能
 * - 多端兼容：适配 app 移动端、H5 端、小程序端
 * 
 * @example
 * // 使用 BEM 规范创建按钮组件
 * @include b(button) {      .wot-button
 *   // 按钮基础样式
 *   
 *   @include e(text) {      .wot-button__text
 *     // 按钮文字样式
 *   }
 *   
 *   @include m(primary) {   .wot-button--primary
 *     // 主要按钮样式
 *   }
 * }
 * 
 * // 使用样式工具
 * .card {
 *   @include halfPixelBorderSurround(); // 0.5px 环绕边框
 *   @include multiEllipsis(2); // 两行文本省略
 * }
 */
@import "config"; // 引入配置变量
@import "function"; // 引入工具函数

/**
  * BEM命名规范 - 定义块（Block） 定义块选择器，生成命名空间前缀的类名
  * @param {string} $block - 块名称
  * @description 生成以命名空间为前缀的块选择器，并将块名称保存为全局变量
  * @example @include b(button) 会生成 .wot-button {...}
  */
@mixin b($block) {
  // 生成全局块名称变量，格式为: 命名空间-块名
  $B: $namespace + "-" + $block !global;

  // 创建块选择器
  .#{$B} {
    @content; // 插入调用者提供的样式内容
  }
}

/**
  * BEM命名规范 - 定义元素（Element） 定义元素选择器，生成块名-元素名的类名
  * @param {list} $element... - 一个或多个元素名称
  * @description 根据上下文智能生成元素选择器，支持伪类嵌套情况
  * @example 在b(button)内部使用@include e(text) 会生成 .wot-button__text {...}
  */
@mixin e($element...) {
  $selector: &; // 获取当前选择器上下文，用于智能判断是否在块内部使用
  $selectors: ""; // 存储生成的选择器字符串

  // 检查是否在伪类内部使用
  // 关键逻辑：智能判断是否需要嵌套生成选择器
  @if containsPseudo($selector) {
    // 如果包含伪类，则生成嵌套的选择器
    // 原因：伪类(:hover, :active等)需要保持与父选择器的关联
    // 为每个元素生成选择器
    @each $item in $element {
      $selectors: #{$selectors + "." + $B + $elementSeparator + $item + ","};
    }

    // 将元素选择器嵌套在伪类内部
    @at-root {
      #{$selector} {
        #{$selectors} {
          @content;
        }
      }
    }
  }

    // 正常情况下的元素选择器生成
    // 逻辑：直接拼接块名和元素名，形成独立的 BEM 选择器
  @else {
    @each $item in $element {
      $selectors: #{$selectors + $selector + $elementSeparator + $item + ","};
    }

    @at-root {
      #{$selectors} {
        @content;
      }
    }
  }
}

/**
  * BEM命名规范 - 定义穿透样式元素（Element with deep） 定义元素选择器，生成块名-元素名的类名，用于穿透组件样式隔离
  * @param {list} $element... - 一个或多个元素名称
  * @description 与e混合宏类似，但生成带有:deep()的元素选择器，用于穿透组件样式隔离
  * @example 在组件中使用@include edeep(text) 会生成 :deep(.wot-button__text) {...}
  * @note 适用于Vue等框架中的样式隔离场景，需要穿透到子组件内部修改样式
  */
@mixin edeep($element...) {
  $selector: &;
  $selectors: "";

  @if containsPseudo($selector) {
    @each $item in $element {
      $selectors: #{$selectors + "." + $B + $elementSeparator + $item + ","};
    }

    @at-root {
      #{$selector} {
        :deep() {
          #{$selectors} {
            @content;
          }
        }
      }
    }
  } @else {
    @each $item in $element {
      $selectors: #{$selectors + $selector + $elementSeparator + $item + ","};
    }

    @at-root {
      :deep() {
        #{$selectors} {
          @content;
        }
      }
    }
  }
}

/**
  * BEM命名规范 - 定义修饰符（Modifier） 定义修饰符选择器，生成块名-修饰符名的类名
  * @param {list} $modifier... - 一个或多个修饰符名称
  * @description 为当前选择器生成修饰符选择器
  * @example 在b(button)内部使用@include m(primary) 会生成 .wot-button--primary {...}
  */
@mixin m($modifier...) {
  $selectors: "";

  // 遍历所有传入的修饰符名称
  // 关键逻辑：为每个修饰符生成对应的选择器
  @each $item in $modifier {
    // 拼接当前选择器上下文和修饰符，形成 .块名--修饰符 格式
    $selectors: #{$selectors + & + $modifierSeparator + $item + ","};
  }

  // 使用 @at-root 将生成的选择器提升到根级别
  // 关键：确保修饰符选择器不会继承嵌套关系，保持 BEM 规范的独立性
  @at-root {
    #{$selectors} {
      @content; // 插入调用者提供的样式内容
    }
  }
}

/**
  * BEM命名规范 - 定义穿透样式修饰符（Modifier with deep） 定义修饰符选择器，生成块名-修饰符名的类名，用于穿透组件样式隔离
  * @param {list} $modifier... - 一个或多个修饰符名称
  * @description 与m混合宏类似，但生成带有:deep()的修饰符选择器
  * @example 在组件中使用@include mdeep(primary) 会生成 :deep(.wot-button--primary) {...}
  * @note 适用于需要穿透组件样式隔离修改修饰符样式的场景
  */
@mixin mdeep($modifier...) {
  $selectors: "";

  @each $item in $modifier {
    $selectors: #{$selectors + & + $modifierSeparator + $item + ","};
  }

  @at-root {
    :deep() {
      #{$selectors} {
        @content;
      }
    }
  }
}

/**
  * BEM命名规范 - 定义修饰符下的元素（Element under Modifier） 定义元素选择器，生成块名-修饰符名-元素名的类名，用于状态切换时元素样式的改变
  * @param {list} $element... - 一个或多个元素名称
  * @description 生成修饰符状态下的元素选择器，用于状态切换时元素样式的改变
  * @example 在m(primary)内部使用@include me(text) 会生成 .wot-button--primary .wot-button__text {...}
  * @note 适用于组件状态切换时（如颜色、尺寸等变化）需要同步改变内部元素样式的场景
  */
@mixin me($element...) {
  $selector: &;
  $selectors: "";

  // 检查当前选择器是否已经是修饰符
  @if containsModifier($selector) {
    @each $item in $element {
      $selectors: #{$selectors + "." + $B + $elementSeparator + $item + ","};
    }

    @at-root {
      #{$selector} {
        #{$selectors} {
          @content;
        }
      }
    }
  } @else {
    @each $item in $element {
      $selectors: #{$selectors + $selector + $elementSeparator + $item + ","};
    }

    @at-root {
      #{$selectors} {
        @content;
      }
    }
  }
}

/**
  * 状态类生成器  定义状态类选择器，生成以状态前缀开头的状态类名
  * @param {list} $states... - 一个或多个状态名称
  * @description 生成以状态前缀开头的状态类选择器
  * @example @include when(active, disabled) 会生成 &.is-active {...} 和 &.is-disabled {...}
  * @note 适用于需要表示组件不同状态的场景，如激活、禁用、加载中等
  */
@mixin when($states...) {
  @at-root {
    @each $state in $states {
      &.#{$state-prefix + $state} {
        @content;
      }
    }
  }
}

/**
  * 常用混合宏集合
  */

/**
 * 单行文本省略混合宏
 * 
 * 用于实现单行文本的省略号显示效果，当文本内容超出容器宽度时自动显示省略号。
 * 这是移动端开发中最常用的文本处理样式之一。
 * 
 * @example
 * // 在卡片标题中使用单行省略
 * .card-title {
 *   @include lineEllipsis;
 *   font-size: 16px;
 *   color: #333;
 * }
 * 
 * // 生成的 CSS
 * // .card-title {
 * //   overflow: hidden;
 * //   white-space: nowrap;
 * //   text-overflow: ellipsis;
 * //   font-size: 16px;
 * //   color: #333;
 * // }
 * 
 * @see multiEllipsis() - 多行文本省略
 * @see textEllipsis() - 通用文本省略
 */
@mixin lineEllipsis {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

/**
  * 多行文本超出省略
  * @param {number} $lineNumber - 显示的行数，默认为3行
  * @description 设置文本在指定行数内显示，超出部分用省略号表示
  * @example 用于描述文本、内容预览等场景
  * @note 该方法使用webkit私有属性，在非webkit内核浏览器可能存在兼容性问题
  */
@mixin multiEllipsis($lineNumber: 3) {
  display: -webkit-box;
  -webkit-box-orient: vertical;
  -webkit-line-clamp: $lineNumber;
  overflow: hidden;
}

/**
  * 清除浮动
  * @description 使用伪元素法清除子元素的浮动影响
  * @example 用于包含浮动元素的容器，确保容器能正确包裹子元素
  */
@mixin clearFloat {
  &::after {
    display: block;
    content: "";
    height: 0;
    clear: both;
    overflow: hidden;
    visibility: hidden;
  }
}

/**
  * 0.5px边框（指定方向）
  * @param {string} $direction - 边框方向，可选值为"bottom"或"top"，默认为"bottom"
  * @param {number|string} $left - 左侧偏移量，默认为0
  * @param {color} $color - 边框颜色，默认为$color-border-light
  * @description 使用伪元素和transform实现0.5px细边框效果
  * @example 用于需要显示极细边框的场景，如列表分割线
  * @note 适用于高分辨率屏幕，可创建比1px更细的视觉效果
  */
@mixin halfPixelBorder($direction: "bottom", $left: 0, $color: $-color-border-light) {
  position: relative;

  &::after {
    position: absolute;
    display: block;
    content: "";

    // 根据左侧偏移量计算宽度
    @if ($left == 0) {
      width: 100%;
    } @else {
      width: calc(100% - #{$left});
    }

    height: 1px;
    left: $left;

    // 根据方向确定定位位置
    @if ($direction == "bottom") {
      bottom: 0;
    } @else {
      top: 0;
    }

    // 使用transform缩放实现0.5px效果
    transform: scaleY(0.5);
    background: $color;
  }
}

/**
  * 0.5px环绕边框
  * @param {color} $color - 边框颜色，默认为$color-border-light
  * @description 使用伪元素和transform实现0.5px的环绕边框效果
  * @example 用于需要显示极细边框的卡片、输入框等组件
  * @note 通过将伪元素尺寸设为200%再缩放50%实现，可适配高分辨率屏幕
  */
@mixin halfPixelBorderSurround($color: $-color-border-light) {
  position: relative;

  &::after {
    position: absolute;
    display: block;
    content: ' ';
    pointer-events: none; // 确保伪元素不影响交互
    width: 200%;
    height: 200%;
    left: 0;
    top: 0;
    border: 1px solid $color;
    transform: scale(0.5); // 缩放到50%实现0.5px效果
    box-sizing: border-box;
    transform-origin: left top; // 以左上角为缩放原点
  }
}

/**
  * 清除按钮默认样式
  * @description 重置按钮的默认外观样式，使其成为透明按钮
  * @example 用于自定义按钮样式，去除浏览器默认样式影响
  */
@mixin buttonClear {
  outline: none;
  -webkit-appearance: none;
  -webkit-tap-highlight-color: transparent; // 消除iOS点击高亮
  background: transparent;
}

/**
  * 三角形箭头（背景透明场景）
  * @param {number|string} $size - 三角形高度，底边长为高度的2倍
  * @param {color} $bg - 三角形背景颜色
  * @description 使用CSS边框实现三角形箭头效果，适用于下拉菜单、提示框等组件
  * @example 用于Popover、Dropdown等需要指示方向的组件
  * @note 生成四种方向的箭头：上、下、左、右
  */
@mixin triangleArrow($size, $bg) {
  // 箭头基础样式
  @include e(arrow) {
    position: absolute;
    width: 0;
    height: 0;
  }

  // 向下箭头
  @include e(arrow-down) {
    border-left: $size solid transparent;
    border-right: $size solid transparent;
    border-top: $size solid $bg;
    transform: translateX(-50%); // 水平居中
    bottom: calc(-1 * $size); // 定位在父元素底部外侧
  }

  // 向上箭头
  @include e(arrow-up) {
    border-left: $size solid transparent;
    border-right: $size solid transparent;
    border-bottom: $size solid $bg;
    transform: translateX(-50%); // 水平居中
    top: calc(-1 * $size); // 定位在父元素顶部外侧
  }

  // 向左箭头
  @include e(arrow-left) {
    border-top: $size solid transparent;
    border-bottom: $size solid transparent;
    border-right: $size solid $bg;
    transform: translateY(-50%); // 垂直居中
    left: calc(-1 * $size); // 定位在父元素左侧外侧
  }

  // 向右箭头
  @include e(arrow-right) {
    border-top: $size solid transparent;
    border-bottom: $size solid transparent;
    border-left: $size solid $bg;
    transform: translateY(-50%); // 垂直居中
    right: calc(-1 * $size); // 定位在父元素右侧外侧
  }
}

/**
  * 正方形箭头（背景不透明场景）
  * @param {number|string} $size - 正方形边长
  * @param {color} $bg - 正方形背景颜色
  * @param {number} $z-index - z-index属性值，需小于外部包裹器
  * @param {string} $box-shadow - 阴影效果
  * @description 使用旋转的正方形实现箭头效果，适用于带背景色和阴影的场景
  * @example 用于Tooltip、Popover等需要与背景色一致的箭头组件
  * @note 通过旋转45度的正方形伪元素实现，可更好地匹配父元素背景和阴影
  */
@mixin squareArrow($size, $bg, $z-index, $box-shadow) {
  // 箭头容器
  @include e(arrow) {
    position: absolute;
    width: $size;
    height: $size;
    z-index: $z-index;
  }

  // 向下箭头
  @include e(arrow-down) {
    transform: translateX(-50%);
    bottom: 0;

    &:after {
      content: "";
      width: $size;
      height: $size;
      background-color: $bg;
      position: absolute;
      left: 0;
      bottom: calc(-1 * $size / 2); // 定位在容器底部中间
      transform: rotateZ(45deg); // 旋转45度形成三角形效果
      box-shadow: $box-shadow;
    }
  }

  // 向上箭头
  @include e(arrow-up) {
    transform: translateX(-50%);
    top: 0;

    &:after {
      content: "";
      width: $size;
      height: $size;
      background-color: $bg;
      position: absolute;
      left: 0;
      top: calc(-1 * $size / 2); // 定位在容器顶部中间
      transform: rotateZ(45deg); // 旋转45度形成三角形效果
      box-shadow: $box-shadow;
    }
  }

  // 向左箭头
  @include e(arrow-left) {
    transform: translateY(-50%);
    left: 0;

    &:after {
      content: "";
      width: $size;
      height: $size;
      background-color: $bg;
      position: absolute;
      left: calc(-1 * $size / 2); // 定位在容器左侧中间
      top: 0;
      transform: rotateZ(45deg); // 旋转45度形成三角形效果
      box-shadow: $box-shadow;
    }
  }

  // 向右箭头
  @include e(arrow-right) {
    transform: translateY(-50%);
    right: 0;

    &:after {
      content: "";
      width: $size;
      height: $size;
      background-color: $bg;
      position: absolute;
      right: calc(-1 * $size / 2); // 定位在容器右侧中间
      top: 0;
      transform: rotateZ(45deg); // 旋转45度形成三角形效果
      box-shadow: $box-shadow;
    }
  }
}

/**
 * 通过scss的mixin功能，把原来需要写4行的css，变成一行
 * 目的是保持代码干净整洁，不至于在nvue下，到处都要写display:flex的条件编译
 */
@mixin flex($direction: row) {
  display: flex;
  flex-direction: $direction;
}
